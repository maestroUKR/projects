__author__ = 'eugene'

import stringToBits as toBits
import lab3
import math
import generators
import time

import pickle
import threading

DEBUG = False

class CriteriyUniformDistribution():
	"""
	Criteriy for checking uniform distribution
	of input prn

	prn: random number generated by
		subclass to Generator()

	return: True or False
	"""
	def __init__(self, prn):
		self.seq_bytes = list()
		div_len = len(prn) - len(prn)%toBits.ASCII_BITS
		for i in range(0, div_len, toBits.ASCII_BITS):
			byte = toBits.bits_to_byte(prn[i:i+8])
			self.seq_bytes.append(byte)
		print "-----------------Start uniform distribution test ... -----------------"

	def computeStatistic(self):
		n = len(self.seq_bytes)/256
		statist = 0
		if n != 0:
			for i in range(256):
				statist += float(pow(self.seq_bytes.count(i) - n, 2))/n
		print "Computed statistic: ", str(statist)
		return statist

	def limitStatistic(self, alfa):
		l = 255
		limit_statist =  lab3.getQuantile(alfa)*math.sqrt(2*l) + l
		print "limit_statist: ", str(limit_statist)
		return limit_statist

	def checkHypotheses(self, alfa):
		if self.computeStatistic() <= self.limitStatistic(alfa):
			print "Ok. PRN has a uniform distribution with alfa = ", str(alfa)
			return True
		else:
			print "FAIL... PRN doesn't pass test for uniform distribution with alfa = ", str(alfa)
			return False

class criteriyIndependence():
	def __init__(self, prn):
		self.seq_bytes = list()
		div_len = len(prn) - len(prn)%toBits.ASCII_BITS
		for i in range(0, div_len, toBits.ASCII_BITS):
			byte = toBits.bits_to_byte(prn[i:i+8])
			self.seq_bytes.append(byte)
		print "-----------------Start independence test ... -----------------"

	def computeStatistic(self):
		n = len(self.seq_bytes)/2
		tmp_seq = self.seq_bytes
		pairs_list = list()
		v_i = list()
		alfa_j = list()

		for i in range(0, len(tmp_seq)-1, 2):
			pair = "(" + str(tmp_seq[i]) + ", " + str(tmp_seq[i+1]) + ")"
			pairs_list.append(pair)

		if DEBUG == True:
			count = 0
			for i in range(256):
				for j in range(256):
					count += pairs_list.count((i,j))

			if count == n:
				print "count == n"
			else:
				print "Error, count != n"

		# compute v_i
		for i in range(256):
			count = 0
			for j in range(256):
				pair = "(" + str(i) + ", " + str(j) + ")"
				count += pairs_list.count(pair)
			v_i.append(count)
		#compute alfa_j
		for j in range(256):
			count = 0
			for i in range(256):
				pair = "(" + str(i) + ", " + str(j) + ")"
				count += pairs_list.count(pair)
			alfa_j.append(count)

		if DEBUG == True:
			print "v_i = ", v_i
			print "alfa_j = ", alfa_j
			print v_i[10]*alfa_j[10]
			print pairs_list[:10]

		statistic = 0
		for i in range(256):
			if v_i[i] != 0 :
				for j in range(256):
					if alfa_j[j] != 0:
						pair = "(" + str(i) + ", " + str(j) + ")"
						statistic += float(pow(pairs_list.count(pair), 2))/(v_i[i]*alfa_j[j])
		statistic = n*(statistic - 1)
		print "Computed statistic: ", str(statistic)
		return statistic

	def limitStatistic(self, alpha):
		l = 255*255
		limit_statist =  lab3.getQuantile(alpha)*math.sqrt(2*l) + l
		print "limit_statist: ", str(limit_statist)
		return limit_statist

	def checkHypotheses(self, alpha):
		if self.computeStatistic() <= self.limitStatistic(alpha):
			print "Ok. PRN has a uniform distribution with alfa = ", str(alpha)
			return True
		else:
			print "FAIL... PRN doesn't pass test for uniform distribution with alfa = ", str(alpha)
			return False

class CriteriySameSeq():
	# r - number of slices
	def __init__(self, prn, r):
		self.seq_bytes = list()
		temp = list()
		div_len = len(prn) - len(prn)%toBits.ASCII_BITS
		for i in range(0, div_len, toBits.ASCII_BITS):
			byte = toBits.bits_to_byte(prn[i:i+8])
			temp.append(byte)
		self.seq_bytes = temp

		self.r = r
		self.len_slice = len(self.seq_bytes)/r
		self.slices_list = list()
		for i in range(0, len(self.seq_bytes) - self.len_slice + 1, self.len_slice):
				self.slices_list.append(self.seq_bytes[i:i+self.len_slice])
		print "-----------------Start same test ... -----------------"
	def computeStatistic(self):
		def computeFrequency(byte, slice):
			count = 0
			for i in xrange(len(slice)):
				if byte == slice[i]:
					count += 1
			return count

		def v_i( i):
			count = 0
			for j in xrange(self.r):
				count += computeFrequency(i, self.slices_list[j])
			return count

		alpha_j = self.len_slice

		statist = 0
		for i in xrange(256):
			if v_i(i) != 0:
				for j in xrange(self.r):
					statist += float(pow(computeFrequency(i,self.slices_list[j]), 2))/float((alpha_j*v_i(i)))

		statist = (statist - 1)*self.len_slice*self.r
		print "Computed statistic: ", str(statist)
		return statist

	def limitStatistic(self, alpha):
		l = 255*(self.r - 1)
		limit_statist =  lab3.getQuantile(alpha)*math.sqrt(2*l) + l
		print "limit_statist: ", str(limit_statist)
		return limit_statist

	def checkHypotheses(self, alpha):
		if self.computeStatistic() <= self.limitStatistic(alpha):
			print "Ok. PRN has a uniform distribution with alfa = ", str(alpha)
			return True
		else:
			print "FAIL... PRN doesn't pass test for uniform distribution with alfa = ", str(alpha)
			return False


if __name__ == '__main__':
	prn = [generators.StandardPythonPRNG(), generators.LSR_20(), generators.LSR_89(), generators.PRNG_fromText(), generators.BBS()]

	for item in prn:
		print "--------------------------------------------------------------------"
		print "Test " + str(item) + " prn ..."
		t1 = time.time()
		gener = item.generate()
		print ("Time of generating: " + str(time.time() - t1))

		t2 = time.time()
		CUD = CriteriyUniformDistribution(gener)
		result = CUD.checkHypotheses(0.05)

		t3 = time.time()
		CUD = criteriyIndependence(gener)
		result = CUD.checkHypotheses(0.05)
		print ("Time of criteriyIndependence: " + str(time.time() - t3))

		t4 = time.time()
		CUD = CriteriySameSeq(gener, 32)
		result = CUD.checkHypotheses(0.05)
		print ("Time of CriteriySameSeq: " + str(time.time() - t4))

		print "--------------------------------------------------------------------"
		print "Require time: " + str(int((time.time() - t1)/60)) + " min " + str(int((time.time() - t1)%60)) + " sec"
		print